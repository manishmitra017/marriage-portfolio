#!/usr/bin/env node

/**
 * generate-gallery.mjs
 *
 * Scans photo folders under public/images/ and generates utils/galleryData.ts.
 *
 * HOW IT WORKS:
 *   1. Each section folder (blessings, couple, signing, family, portraits, feast)
 *      is scanned for image files (.jpg, .jpeg, .png, .webp).
 *   2. If a _captions.json exists in the folder, it provides alt text, captions,
 *      and — crucially — the display order. Photos listed in _captions.json appear
 *      first, in that order. Any new photos not in _captions.json are appended
 *      alphabetically at the end.
 *   3. Photos without a _captions.json entry get a generic alt derived from the
 *      folder name and filename.
 *
 * FOR CONTRIBUTORS:
 *   - To ADD a photo:    Drop it into the right folder (e.g. public/images/blessings/).
 *   - To REMOVE a photo: Delete the file from the folder.
 *   - To set alt/caption: Edit _captions.json in that folder (optional).
 *   - The build step runs this script automatically before every build/dev.
 */

import { readdirSync, readFileSync, writeFileSync, existsSync } from 'node:fs';
import { join, extname, basename, resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = resolve(__dirname, '..');
const IMAGES_DIR = join(ROOT, 'public', 'images');
const OUTPUT = join(ROOT, 'utils', 'galleryData.ts');

const IMAGE_EXTS = new Set(['.jpg', '.jpeg', '.png', '.webp']);
const VIDEO_EXTS = new Set(['.mp4', '.mov', '.webm']);
const MEDIA_EXTS = new Set([...IMAGE_EXTS, ...VIDEO_EXTS]);

// Section config: folder name → export name, display order matches page layout
const SECTIONS = [
  { folder: 'pre-wedding', exportName: 'preWeddingGalleryPhotos' },
  { folder: 'blessings', exportName: 'blessingPhotos' },
  { folder: 'couple', exportName: 'couplePhotos' },
  { folder: 'signing', exportName: 'signingPhotos' },
  { folder: 'family', exportName: 'familyPhotos' },
  { folder: 'portraits', exportName: 'portraitSectionPhotos' },
  { folder: 'feast', exportName: 'feastPhotos' },
  { folder: 'pre-haldi', exportName: 'preHaldiPhotos' },
  { folder: 'haldi', exportName: 'haldiPhotos' },
  { folder: 'wedding', exportName: 'weddingPhotos' },
  { folder: 'sindoor-daan', exportName: 'sindoorDaanPhotos' },
  { folder: 'post-wedding', exportName: 'postWeddingPhotos' },
];

function getMediaFiles(folderPath) {
  if (!existsSync(folderPath)) return [];
  return readdirSync(folderPath).filter(
    (f) => MEDIA_EXTS.has(extname(f).toLowerCase()) && !f.startsWith('_')
  );
}

function loadCaptions(folderPath) {
  const captionsPath = join(folderPath, '_captions.json');
  if (!existsSync(captionsPath)) return null;
  try {
    return JSON.parse(readFileSync(captionsPath, 'utf-8'));
  } catch (e) {
    console.warn(`Warning: Failed to parse ${captionsPath}: ${e.message}`);
    return null;
  }
}

function humanize(folder) {
  return folder.charAt(0).toUpperCase() + folder.slice(1).replace(/-/g, ' ');
}

function escapeTS(str) {
  return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

function buildPhotoArray(folder) {
  const folderPath = join(IMAGES_DIR, folder);
  const allFiles = getMediaFiles(folderPath);
  const captions = loadCaptions(folderPath);

  // Determine display order: _captions.json order first, then remaining files alphabetically
  let ordered;
  if (captions) {
    const captionKeys = Object.keys(captions);
    const captionSet = new Set(captionKeys);
    const remaining = allFiles.filter((f) => !captionSet.has(f)).sort();
    // Only include caption entries that actually have a file on disk
    const existing = captionKeys.filter((f) => allFiles.includes(f));
    ordered = [...existing, ...remaining];
  } else {
    ordered = [...allFiles].sort();
  }

  return ordered.map((filename) => {
    const src = `/images/${folder}/${filename}`;
    const ext = extname(filename).toLowerCase();
    const isVideo = VIDEO_EXTS.has(ext);
    const meta = captions?.[filename];
    const alt = meta?.alt || `${humanize(folder)} ${isVideo ? 'video' : 'photo'} — ${basename(filename, ext)}`;
    const caption = meta?.caption || '';
    const item = { src, alt, caption };
    if (isVideo) item.type = 'video';
    return item;
  });
}

function generate() {
  const sections = SECTIONS.map(({ folder, exportName }) => {
    const photos = buildPhotoArray(folder);
    console.log(`  ${folder}/: ${photos.length} photos`);
    return { exportName, photos };
  });

  const lines = [
    '// AUTO-GENERATED by scripts/generate-gallery.mjs — do not edit manually.',
    '// To regenerate: node scripts/generate-gallery.mjs',
    '//',
    '// To add/remove photos, just add or delete image files from the folders',
    '// under public/images/. Optionally update _captions.json in that folder for alt text and captions.',
    '',
    "import { GalleryPhoto } from '@/components/PhotoGallery';",
    '',
  ];

  for (const { exportName, photos } of sections) {
    lines.push(`export const ${exportName}: GalleryPhoto[] = [`);
    for (const p of photos) {
      const typePart = p.type ? `, type: '${p.type}'` : '';
      lines.push(`  { src: '${escapeTS(p.src)}', alt: '${escapeTS(p.alt)}', caption: '${escapeTS(p.caption)}'${typePart} },`);
    }
    lines.push('];');
    lines.push('');
  }

  // Legacy exports for backward compatibility
  lines.push('// Legacy exports for backward compatibility');
  lines.push('export const ceremonyPhotos = blessingPhotos;');
  lines.push('export const receptionPhotos = couplePhotos;');
  lines.push('export const portraitPhotos = familyPhotos;');
  lines.push('export const preWeddingPhotos = feastPhotos;');
  lines.push('');

  writeFileSync(OUTPUT, lines.join('\n'), 'utf-8');
  console.log(`\n  Generated ${OUTPUT}`);
}

console.log('Generating gallery data from image folders...\n');
generate();
